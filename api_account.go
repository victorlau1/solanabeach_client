/*
Solanabeach Backend API

Solanabeach Backend REST API documentation.  ## Rate limiting Current API rate limit per IP is 100 requests per second.    ## Pagination Most of the endpoints returning array data support pagination. The API uses two types of pagination, depending on the returned data. Some endpoints support both, some are limited to just one type.    ## Supported pagination types ### Offset / limit Offset / limit pagination is the simplest form of pagination supported by the API. Offset parameter represents the number of results to skip before returning the data, and the limit parameter limits the number of returned results.   To prevent overloading the API, all limit params have a max value. Each API endpoint has its own max value.  ### Cursor Cursor pagination is more complex than the offset / limit one, but, it comes naturally for some blockchain data (such as blocks, transactions, token transfers, etc). Cursors contain data like blocknumber, transaction index, ... and they're described on their respective API endpoints. Limit parameter works exactly the same way as it does in the offset / limit pagination.  ## Authentication The public API uses a Bearer OAuth authentication method, and the API key should be provided in the `Authorization` header in each request. API keys are issued on request. 

API version: 0.0.1
Contact: andrej@vgng.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AccountApiService AccountApi service
type AccountApiService service

type ApiFetchAccountRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
}


func (r ApiFetchAccountRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountExecute(r)
}

/*
FetchAccount Fetch account data

Fetch account data

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountRequest
*/
func (a *AccountApiService) FetchAccount(ctx _context.Context, pubkey string) ApiFetchAccountRequest {
	return ApiFetchAccountRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountApiService) FetchAccountExecute(r ApiFetchAccountRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountSerumInstructionsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
	cursor *string
}

// Result limit (max 100)
func (r ApiFetchAccountSerumInstructionsRequest) Limit(limit int32) ApiFetchAccountSerumInstructionsRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountSerumInstructionsRequest) Offset(offset int32) ApiFetchAccountSerumInstructionsRequest {
	r.offset = &offset
	return r
}
// Serum instruction cursor (blocknumber,txindex,index)
func (r ApiFetchAccountSerumInstructionsRequest) Cursor(cursor string) ApiFetchAccountSerumInstructionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchAccountSerumInstructionsRequest) Execute() ([]AccountSerumInstruction, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountSerumInstructionsExecute(r)
}

/*
FetchAccountSerumInstructions Fetch account serum instructions

Fetch account serum instructions ordered by block number

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountSerumInstructionsRequest
*/
func (a *AccountApiService) FetchAccountSerumInstructions(ctx _context.Context, pubkey string) ApiFetchAccountSerumInstructionsRequest {
	return ApiFetchAccountSerumInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []AccountSerumInstruction
func (a *AccountApiService) FetchAccountSerumInstructionsExecute(r ApiFetchAccountSerumInstructionsRequest) ([]AccountSerumInstruction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AccountSerumInstruction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountSerumInstructions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/serum-instructions"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountSerumOrdersRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
	cursor *string
}

// Result limit (max 100)
func (r ApiFetchAccountSerumOrdersRequest) Limit(limit int32) ApiFetchAccountSerumOrdersRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountSerumOrdersRequest) Offset(offset int32) ApiFetchAccountSerumOrdersRequest {
	r.offset = &offset
	return r
}
// Serum orders cursor (blocknumber,txindex)
func (r ApiFetchAccountSerumOrdersRequest) Cursor(cursor string) ApiFetchAccountSerumOrdersRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchAccountSerumOrdersRequest) Execute() ([]AccountSerumOrder, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountSerumOrdersExecute(r)
}

/*
FetchAccountSerumOrders Fetch account serum orders

Fetch account serum orders ordered by block number

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountSerumOrdersRequest
*/
func (a *AccountApiService) FetchAccountSerumOrders(ctx _context.Context, pubkey string) ApiFetchAccountSerumOrdersRequest {
	return ApiFetchAccountSerumOrdersRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []AccountSerumOrder
func (a *AccountApiService) FetchAccountSerumOrdersExecute(r ApiFetchAccountSerumOrdersRequest) ([]AccountSerumOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AccountSerumOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountSerumOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/serum-orders"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountSwapInstructionsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
	cursor *string
}

// Result limit (max 100)
func (r ApiFetchAccountSwapInstructionsRequest) Limit(limit int32) ApiFetchAccountSwapInstructionsRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountSwapInstructionsRequest) Offset(offset int32) ApiFetchAccountSwapInstructionsRequest {
	r.offset = &offset
	return r
}
// Swap instruction cursor (blocknumber,txindex,index)
func (r ApiFetchAccountSwapInstructionsRequest) Cursor(cursor string) ApiFetchAccountSwapInstructionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchAccountSwapInstructionsRequest) Execute() ([]AccountSwapInstruction, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountSwapInstructionsExecute(r)
}

/*
FetchAccountSwapInstructions Fetch account swap instructions

Fetch account swap instructions ordered by block number

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountSwapInstructionsRequest
*/
func (a *AccountApiService) FetchAccountSwapInstructions(ctx _context.Context, pubkey string) ApiFetchAccountSwapInstructionsRequest {
	return ApiFetchAccountSwapInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []AccountSwapInstruction
func (a *AccountApiService) FetchAccountSwapInstructionsExecute(r ApiFetchAccountSwapInstructionsRequest) ([]AccountSwapInstruction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AccountSwapInstruction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountSwapInstructions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/swap-instructions"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountTokenTransfersRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
	cursor *string
	inner *bool
}

// Result limit (max 100)
func (r ApiFetchAccountTokenTransfersRequest) Limit(limit int32) ApiFetchAccountTokenTransfersRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountTokenTransfersRequest) Offset(offset int32) ApiFetchAccountTokenTransfersRequest {
	r.offset = &offset
	return r
}
// Token transfers cursor (blocknumber,txindex)
func (r ApiFetchAccountTokenTransfersRequest) Cursor(cursor string) ApiFetchAccountTokenTransfersRequest {
	r.cursor = &cursor
	return r
}
// Filter inner instructions
func (r ApiFetchAccountTokenTransfersRequest) Inner(inner bool) ApiFetchAccountTokenTransfersRequest {
	r.inner = &inner
	return r
}

func (r ApiFetchAccountTokenTransfersRequest) Execute() ([]AccountTokenTransfer, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountTokenTransfersExecute(r)
}

/*
FetchAccountTokenTransfers Fetch account token transfers

Fetch account token transfers ordered by block number

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountTokenTransfersRequest
*/
func (a *AccountApiService) FetchAccountTokenTransfers(ctx _context.Context, pubkey string) ApiFetchAccountTokenTransfersRequest {
	return ApiFetchAccountTokenTransfersRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []AccountTokenTransfer
func (a *AccountApiService) FetchAccountTokenTransfersExecute(r ApiFetchAccountTokenTransfersRequest) ([]AccountTokenTransfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AccountTokenTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountTokenTransfers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/token-transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.inner != nil {
		localVarQueryParams.Add("inner", parameterToString(*r.inner, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountTokensRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
}

// Result limit (max 100)
func (r ApiFetchAccountTokensRequest) Limit(limit int32) ApiFetchAccountTokensRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountTokensRequest) Offset(offset int32) ApiFetchAccountTokensRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchAccountTokensRequest) Execute() ([]AccountToken, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountTokensExecute(r)
}

/*
FetchAccountTokens Fetch account tokens

Fetch account tokens

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountTokensRequest
*/
func (a *AccountApiService) FetchAccountTokens(ctx _context.Context, pubkey string) ApiFetchAccountTokensRequest {
	return ApiFetchAccountTokensRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []AccountToken
func (a *AccountApiService) FetchAccountTokensExecute(r ApiFetchAccountTokensRequest) ([]AccountToken, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AccountToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountTokens")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountTransactionsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
	cursor *string
}

// Result limit (max 1000)
func (r ApiFetchAccountTransactionsRequest) Limit(limit int32) ApiFetchAccountTransactionsRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountTransactionsRequest) Offset(offset int32) ApiFetchAccountTransactionsRequest {
	r.offset = &offset
	return r
}
// Transaction cursor (blocknumber,txindex)
func (r ApiFetchAccountTransactionsRequest) Cursor(cursor string) ApiFetchAccountTransactionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchAccountTransactionsRequest) Execute() ([]Transaction, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountTransactionsExecute(r)
}

/*
FetchAccountTransactions Fetch account transactions

Fetch account transactions ordered by block number

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchAccountTransactionsRequest
*/
func (a *AccountApiService) FetchAccountTransactions(ctx _context.Context, pubkey string) ApiFetchAccountTransactionsRequest {
	return ApiFetchAccountTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []Transaction
func (a *AccountApiService) FetchAccountTransactionsExecute(r ApiFetchAccountTransactionsRequest) ([]Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccountTransactions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAccountsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	limit *int32
	offset *int32
}

// Result limit (max 1000)
func (r ApiFetchAccountsRequest) Limit(limit int32) ApiFetchAccountsRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchAccountsRequest) Offset(offset int32) ApiFetchAccountsRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchAccountsRequest) Execute() ([]SimpleAccount, *_nethttp.Response, error) {
	return r.ApiService.FetchAccountsExecute(r)
}

/*
FetchAccounts Fetch accounts

Fetch accounts ordered by balance

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchAccountsRequest
*/
func (a *AccountApiService) FetchAccounts(ctx _context.Context) ApiFetchAccountsRequest {
	return ApiFetchAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SimpleAccount
func (a *AccountApiService) FetchAccountsExecute(r ApiFetchAccountsRequest) ([]SimpleAccount, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SimpleAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchStakeAccountRewardsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	stakePubkey string
	cursor *int32
}

// Epoch cursor
func (r ApiFetchStakeAccountRewardsRequest) Cursor(cursor int32) ApiFetchStakeAccountRewardsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchStakeAccountRewardsRequest) Execute() ([]StakeAccountReward, *_nethttp.Response, error) {
	return r.ApiService.FetchStakeAccountRewardsExecute(r)
}

/*
FetchStakeAccountRewards Fetch stake account rewards

Fetch stake account rewards by the stake account pubkey

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stakePubkey Stake account address
 @return ApiFetchStakeAccountRewardsRequest
*/
func (a *AccountApiService) FetchStakeAccountRewards(ctx _context.Context, stakePubkey string) ApiFetchStakeAccountRewardsRequest {
	return ApiFetchStakeAccountRewardsRequest{
		ApiService: a,
		ctx: ctx,
		stakePubkey: stakePubkey,
	}
}

// Execute executes the request
//  @return []StakeAccountReward
func (a *AccountApiService) FetchStakeAccountRewardsExecute(r ApiFetchStakeAccountRewardsRequest) ([]StakeAccountReward, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []StakeAccountReward
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchStakeAccountRewards")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{stake_pubkey}/stake-rewards"
	localVarPath = strings.Replace(localVarPath, "{"+"stake_pubkey"+"}", _neturl.PathEscape(parameterToString(r.stakePubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchStakeAccountsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
	pubkey string
	limit *int32
	offset *int32
}

// Result limit (max 1000)
func (r ApiFetchStakeAccountsRequest) Limit(limit int32) ApiFetchStakeAccountsRequest {
	r.limit = &limit
	return r
}
// Result offset
func (r ApiFetchStakeAccountsRequest) Offset(offset int32) ApiFetchStakeAccountsRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchStakeAccountsRequest) Execute() ([]StakeAccount, *_nethttp.Response, error) {
	return r.ApiService.FetchStakeAccountsExecute(r)
}

/*
FetchStakeAccounts Fetch stake accounts

Fetch stake accounts owned by the pubkey

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pubkey Account address
 @return ApiFetchStakeAccountsRequest
*/
func (a *AccountApiService) FetchStakeAccounts(ctx _context.Context, pubkey string) ApiFetchStakeAccountsRequest {
	return ApiFetchStakeAccountsRequest{
		ApiService: a,
		ctx: ctx,
		pubkey: pubkey,
	}
}

// Execute executes the request
//  @return []StakeAccount
func (a *AccountApiService) FetchStakeAccountsExecute(r ApiFetchStakeAccountsRequest) ([]StakeAccount, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []StakeAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchStakeAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/account/{pubkey}/stakes"
	localVarPath = strings.Replace(localVarPath, "{"+"pubkey"+"}", _neturl.PathEscape(parameterToString(r.pubkey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchWealthMetricsRequest struct {
	ctx _context.Context
	ApiService *AccountApiService
}


func (r ApiFetchWealthMetricsRequest) Execute() (Wealth, *_nethttp.Response, error) {
	return r.ApiService.FetchWealthMetricsExecute(r)
}

/*
FetchWealthMetrics Fetch wealth distribution metrics

Fetch wealth distribution metrics

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchWealthMetricsRequest
*/
func (a *AccountApiService) FetchWealthMetrics(ctx _context.Context) ApiFetchWealthMetricsRequest {
	return ApiFetchWealthMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Wealth
func (a *AccountApiService) FetchWealthMetricsExecute(r ApiFetchWealthMetricsRequest) (Wealth, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Wealth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountApiService.FetchWealthMetrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wealth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
